遺伝的プログラミング(GP)でのゲームAIの探索(gp_snake)
========

遺伝的プログラミング(GP)でスネークゲームのヘビのより適した生存戦略、つまりヘビのゲームAIを探索させる。

##How to use
####探索の実行
./gp_snake 

探索を実行する。OpenMPで並列処理での探索が可能。
#####出力の読み方
(世代数)th Gen Max score gene is (最も優秀な遺伝子の番号)	 len : (成長したヘビの最大長の平均)	time : (生存時間の平均)	gene : (S式-likeな遺伝子の表現)

####シミュレーション
./gp_snake -s 

S式-likeな表記で遺伝子を与え、シミュレーションをすることが可能。

##遺伝的プログラミング(GP)とは？
平たく言えば、生物が進化するシステムを応用して、より適した解を探索させるアルゴリズム。

遺伝的アルゴリズムと違い、遺伝的プログラミングでは、プログラムを表現することができるので、ゲームのAIなどの探索を行うことが可能。

探索するAIのプログラムの構造(これは木構造で表される)を遺伝子として持ち、選択・交叉・突然変異を繰り返して優秀な遺伝子を選び、劣った遺伝子は淘汰される。

こうした次世代の新たな遺伝子を得る作業を繰り返す。
###選択
次世代の遺伝子を選ぶ。適応度を計算し、より優秀な遺伝子を残すように選択。
###交叉
遺伝子の木の一部分を入れ替えて新たな遺伝子を得る。
###突然変異
遺伝子の木の一部分を全く新たな遺伝子に入れ替える。

詳細は[Wikipediaの解説](http://ja.wikipedia.org/wiki/%E9%81%BA%E4%BC%9D%E7%9A%84%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)を参照。

##スネークゲーム
M-x snakeでお馴染みのあのゲーム。20×20のフィールドの中で、ヘビを操って餌を食べさせるゲーム。

餌を食べるとヘビの長さは1成長する。壁やヘビ自身の体にぶつかったらゲームオーバー。

今回のプログラムでは、探索時間の都合上、元のゲームのルールと異なり、200ターン餌を食べないとゲームオーバーになるよう設定した。

##ヘビのAI
今回のAIでヘビができることは以下のとおり。
###移動
l : ヘビが左に1マス前進する。
f : ヘビが前に1マス前進する。
r : ヘビが右に1マス前進する。
###情報収集
この関数群では、フィールドの情報を収集し、その情報によって行う動作を決定する。
####障害物の検知
if-0 : ヘビの頭の1マス左側に障害物(自身の体・壁)があるかチェックする。

if-1 : ヘビの頭の1マス前方に障害物(自身の体・壁)があるかチェックする。

if-2 : ヘビの頭の1マス右側に障害物(自身の体・壁)があるかチェックする。
####餌の検知
if-3 : ヘビの頭の1マス左側に餌があるかチェックする。

if-4 : ヘビの頭の1マス前方に餌があるかチェックする。

if-5 : ヘビの頭の1マス右側に餌があるかチェックする。
####餌の大まかな方角を知る
if-6 : 餌がヘビの頭から見て、前方の方角に餌があるかチェックする。

if-7 : 餌がヘビの頭から見て、左の方角に餌があるかチェックする。

if-8 : 餌がヘビの頭から見て、右の方角に餌があるかチェックする。
###連続した動作を行う関数
proc : 2つの指示した動作を連続して行う。

ヘビのAIは、この関数群を組み合わせた木構造で表される。うち終端記号となるのは、移動の3動作、情報収集用のif関数群と動作を連続させるproc関数は非終端記号となる。

このAIは、LispのS式-likeな表記で表される。例えば、

(if-6 f (if-2 l r))

のように表される。

##探索の過程
以下の処理を繰り返して、新たな世代の遺伝子を得る。
###適応度の計算
各遺伝子の優秀さを表すスコアは、以下の計算式で定義される。

pow(W_POW,<生存時間>/<とった餌の数+1>*W_TIME + <ヘビの長さ>*W_LEN) + CON

(W_LEN = 1.0, W_TIME = -0.22, W_POW 1.23, CON 0.00 とした。)

つまり、より成長できたヘビはより優秀であり、より餌を取る効率が良いヘビがより優秀だと定義した。

ただし、ある程度誤差を小さくするため、100回繰り返してその平均値を使用。

###選択
求めた適応度のスコアに比例する確率で、各遺伝子を選択する。いわゆるルーレット選択方式。
###交叉
別々の木からランダムに交叉点を1点ずつ選択し、その点から下の部分木を入れ替える。
###突然変異
ランダムに木のノードを選択し、その点から下の部分木をまったく新しい部分木に入れ替え。

##探索結果
各世代において、最も優秀な遺伝子を表示させる。

0th Gen Max score gene is 35	 len : 9.15	time : 88.68	gene : (if-6 f l)

5th Gen Max score gene is 6	 len : 16.82	time : 417.96	gene : (if-6 f (if-6 l (if-0 l (if-4 l f))))

10th Gen Max score gene is 28	 len : 26.24	time : 432.7	gene : (if-6 f (if-6 l (if-8 r (if-3 l (if-1 l f)))))

20th Gen Max score gene is 15	 len : 26.74	time : 436.31	gene : (if-6 f (if-6 l (if-8 (if-7 (if-1 (if-4 r (if-4 (if-2 (if-0 f (if-5 (if-6 (if-1 l (if-3 l (if-3 f r))) r) l)) f) f)) f) (if-7 f (if-4 (if-7 l f) r))) (if-3 l (if-1 l f)))))

30th Gen Max score gene is 42	 len : 26.31	time : 427.33	gene : (if-6 f (if-6 f (if-8 r (if-3 l (if-1 l f)))))

40th Gen Max score gene is 27	 len : 39.37	time : 1114.93	gene : (if-6 f (if-6 l (if-3 l (if-4 l (if-1 l f)))))

50th Gen Max score gene is 47	 len : 39.77	time : 1136.96	gene : (if-6 f (if-6 f (if-3 l (if-4 l (if-1 l f)))))

100th Gen Max score gene is 43	 len : 39.66	time : 1133.14	gene : (if-6 (if-6 f (if-6 l (if-3 r (if-0 f r)))) (if-6 (if-3 (if-4 (if-0 r f) (if-0 l (if-7 r (if-0 l r)))) (if-4 f (if-1 l f))) (if-3 (if-6 r f) (if-4 l (if-1 l f)))))

150th Gen Max score gene is 37	 len : 42.49	time : 1240.24	gene : (if-6 (if-2 f r) (if-6 l (if-3 f (if-4 l (if-1 l f)))))

200th Gen Max score gene is 43	 len : 46.51	time : 1847.89	gene : (if-6 (if-2 f r) (if-6 (if-4 l (if-0 (if-8 f r) (if-8 (proc f r) (if-1 (if-7 l r) (if-6 (if-1 r (if-7 r (if-8 l f))) r))))) (if-3 r (if-1 l (if-8 (if-5 l (if-5 r (if-3 l f))) (if-8 l r))))))

300th Gen Max score gene is 36	 len : 48.89	time : 1934.27	gene : (if-6 (if-2 f r) (if-6 (if-4 (if-2 f r) r) (if-3 f (if-1 l (if-8 (if-5 r f) (if-8 (if-5 (if-3 r (if-5 (proc l f) r)) (if-4 l r)) r))))))


世代を経るごとに、ヘビのAIは複雑になり、かつ優秀になっていることがわかる.
